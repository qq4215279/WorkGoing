字符串问题可谓是 Java 中经久不衰的问题，尤其是字符串常量池经常作为面试题出现。可即便是看似简单而又经常被提起的问题，还是有好多同学一知半解，看上去懂了，仔细分析起来却有发现不太明白。

## 背景说明

本文以 JDK 1.8 为讨论版本，虽然现在都已经 JDK 14了，奈何我们还是钟爱 1.8。

## 字符串常量池何许人也

为什么要有字符串常量池呢，像其他对象一样直接存在堆中不行吗，这就要问 Java 语言的设计者了，当然，这么做也并不是拍脑袋想出来的。

这就要从字符串说起。

首先对象的分配要付出时间和空间上的开销，字符串可以说是和 8 个基本类型一样常用的类型，甚至比 8 个基本类型更加常用，故而频繁的创建字符串对象，对性能的影响是非常大的，所以，用常量池的方式可以很大程度上降低对象创建、分配的次数，从而提升性能。

在 JDK 1.7 之后(包括1.7)，`字符串常量池已经从方法区移到了堆中`。

### 1. 字面量赋值

我们把上面的那个实例代码拿过来

```java
String s1 = "古时的风筝";
```

这是我们平时声明字符串变量的最常用的方式，这种方式叫做字面量声明，也就用把字符串用双引号引起来，然后赋值给一个变量。

这种情况下会直接将字符串放到字符串常量池中，然后返回给变量。

![img](assets\字符串初始化本质\v2-cf80e3196f3281773f47f75c14bbadb5_720w.jpg)

那这是我再声明一个内容相同的字符串，会发现字符串常量池中已经存在了，那直接指向常量池中的地址即可。

![img](assets\字符串初始化本质\v2-14de56e3d11f28e17c80c4cc27a039c4_720w.jpg)

例如上图所示，声明了 s1 和 s2，到最后都是指向同一个常量池的地址，所以 s1== s2 的结果是 true。

### 2. new String() 方式

与之对应的是用 new String() 的方式，但是基本上不建议这么用，除非有特殊的逻辑需要。

```java
String a = "古时的";
String s2 = new String(a + "风筝");
```

使用这种方式声明字符串变量的时候，会有两种情况发生。

1. 第一种情况，字符串常量池之前已经存在相同字符串
2. 第二种情况，字符串常量池中不存在相同内容的常量

#### 字符串常量池之前已经存在相同字符串

比如在使用 new 之前，已经用字面量声明的方式声明了一个变量，此时字符串常量池中已经存在了相同内容的字符串常量。

1. 首先会在堆中创建一个 s2 变量的对象引用；
2. 然后将这个对象引用指向字符串常量池中的已经存在的常量；

![img](assets\字符串初始化本质\v2-3bd1df6796e4aebce48b41ba70fae5a2_720w.jpg)



#### 字符串常量池中不存在相同内容的常量

之前没有任何地方用到了这个字符串，第一次声明这个字符串就用的是 new String() 的方式，这种情况下会直接在堆中创建一个字符串对象然后返回给变量。

![img](assets\字符串初始化本质\v2-4631d629793b1830c4770fcbe3049f78_720w.jpg)

**我看到好多地方说，如果字符串常量池中不存在的话，就先把字符串先放进去，然后再引用字符串常量池的这个常量对象，这种说法是有问题的，只是 new String() 的话，如果池中没有也不会放一份进去。**

基于 new String() 的这种特性，我们可以得出一个结论：

```java
String s1 = "古时的风筝";
String a = "古时的";
String s2 = new String(a + "风筝");
String s3 = new String(a + "风筝");
System.out.println(s1==s2); // false
System.out.println(s2==s3);  // false
```

以上代码，肯定输出的都是 false，因为 new String() 不管你常量池中有没有，我都会在堆中新建一个对象，新建出来的对象，当然不会和其他对象相等。

### intern() 池化

那什么时候会放到字符串常量池呢，就是在使用 intern() 方法之后。

intern() 的定义：如果当前字符串内容存在于字符串常量池，存在的条件是使用 equas() 方法为ture，也就是内容是一样的，那直接返回此字符串在常量池的引用；如果之前不在字符串常量池中，那么在常量池创建一个引用并且指向堆中已存在的字符串，然后返回常量池中的地址。

池化有两种情况：

1. 第一种情况，准备池化的字符串与字符串常量池中的字符串有相同(equas()判断)
2. 第二种情况，字符串常量池中不存在相同内容的字符串



#### 准备池化的字符串与字符串常量池中的字符串有相同(equas()判断)

```java
String s1 = "古时的风筝";
String a = "古时的";
String s2 = new String(a + "风筝");
s2 = s2.intern();
```

这时，这个字符串常量已经在常量池存在了，这时，再 new 了一个新的对象 s2，并在堆中创建了一个相同字符串内容的对象。

![img](assets\字符串初始化本质\v2-96d8dc11a5376b29885e1dad08783256_720w.jpg)



这时，s1 == s2 会返回 fasle。然后我们调用 s2 = s2.intern()，将池化操作返回的结果赋值给 s2，就会发生如下的变化。

![img](assets\字符串初始化本质\v2-25697779619aaa96d7b2cc9485c1466c_720w.jpg)

此时，再次判断 s1 == s2 ，就会返回 true，因为它们都指向了字符串常量池的同一个字符串。

#### 字符串常量池中不存在相同内容的字符串

使用 new String() 在堆中创建了一个字符串对象

![img](assets\字符串初始化本质\v2-4631d629793b1830c4770fcbe3049f78_720w(1).jpg)



使用了 intern() 之后发生了什么呢，在常量池新增了一个对象，但是 **并没有** 将字符串复制一份到常量池，而是直接指向了之前已经存在于堆中的字符串对象。

因为在 JDK 1.7 之后，字符串常量池不一定就是存字符串对象的，还有可能存储的是一个指向堆中地址的引用，现在说的就是这种情况，注意了，下图是只调用了 s2.intern()，并没有返回给一个变量。其中字符串常量池（0x88）指向堆中字符串对象（0x99）就是intern() 的过程。

![img](assets\字符串初始化本质\v2-f8b0ec2f032ca67481fb6de1e08df0b1_720w.jpg)



只有当我们把 s2.intern() 的结果返回给 s2 时，s2 才真正的指向字符串常量池。

![img](assets\字符串初始化本质\v2-677e02e7a346b10bb7e946a3070e79b7_720w.jpg)



### 我明白了

通过以上的介绍，我们来看下面的一段代码返回的结果是什么

```java
public class Test {

    public static void main(String[] args) {
        String a = "古时的";
        String s1 = "古时的风筝";
        String s2 = "古时的风筝";
        String s3 = new String(a + "风筝");
        String s4 = new String(a + "风筝");
        
        System.out.println(s1 == s2); // 【1】 true
        System.out.println(s2 == s3); // 【2】 false
        System.out.println(s3 == s4); // 【3】 false
        s3.intern();
        System.out.println(s2 == s3); // 【4】 false
        s3 = s3.intern();
        System.out.println(s2 == s3); // 【5】 true
        s4 = s4.intern();
        System.out.println(s3 == s4); // 【6】 true
    }
}
```

【1】：s1 == s2 返回 ture，因为都是字面量声明，全都指向字符串常量池中同一字符串。

【2】: s2 == s3 返回 false，因为 new String() 是在堆中新建对象，所以和常量池的常量不相同。

【3】: s3 == s4 返回 false，都是在堆中新建对象，所以是两个对象，肯定不相同。

【4】: s2 == s3 返回 false，前面虽然调用了 intern() ，但是没有返回，不起作用。

【5】: s2 == s3 返回 ture，前面调用了 intern() ，并且返回给了 s3 ，此时 s2、s3 都直接指向常量池的同一个字符串。

【6】: s3 == s4 返回 true，和 s3 相同，都指向了常量池同一个字符串。